// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.190730.2

#pragma once
#include "winrt/base.h"
#include "winrt/Microsoft.Toolkit.Win32.UI.XamlHost.h"
#include "winrt/Windows.Foundation.h"
#include "winrt/Windows.Foundation.Collections.h"
#include "winrt/Windows.UI.Xaml.h"
#include "winrt/Windows.UI.Xaml.Markup.h"
namespace winrt::Microsoft::Toolkit::Win32::UI::XamlHost::implementation
{
    template <typename D, typename... I>
    struct __declspec(empty_bases) XamlApplication_base : implements<D, Microsoft::Toolkit::Win32::UI::XamlHost::XamlApplication, Windows::Foundation::IClosable, composable, composing, Windows::UI::Xaml::IApplicationOverrides, Windows::UI::Xaml::IApplicationOverrides2, I...>,
        impl::require<D, Windows::UI::Xaml::IApplication, Windows::UI::Xaml::IApplication2, Windows::UI::Xaml::IApplication3>,
        impl::base<D, Windows::UI::Xaml::Application>,
        Windows::UI::Xaml::IApplicationOverridesT<D>, Windows::UI::Xaml::IApplicationOverrides2T<D>
    {
        using base_type = XamlApplication_base;
        using class_type = Microsoft::Toolkit::Win32::UI::XamlHost::XamlApplication;
        using implements_type = typename XamlApplication_base::implements_type;
        using implements_type::implements_type;
        using composable_base = Windows::UI::Xaml::Application;
        hstring GetRuntimeClassName() const
        {
            return L"Microsoft.Toolkit.Win32.UI.XamlHost.XamlApplication";
        }
        XamlApplication_base()
        {
            impl::call_factory<Windows::UI::Xaml::Application, Windows::UI::Xaml::IApplicationFactory>([&](auto&& f) { f.CreateInstance(*this, this->m_inner); });
        }

    protected:
        using dispatch = impl::dispatch_to_overridable<D, Windows::UI::Xaml::IApplicationOverrides, Windows::UI::Xaml::IApplicationOverrides2>;
        auto overridable() noexcept { return dispatch::overridable(static_cast<D&>(*this)); }
    };
}
namespace winrt::Microsoft::Toolkit::Win32::UI::XamlHost::factory_implementation
{
    template <typename D, typename T, typename... I>
    struct __declspec(empty_bases) XamlApplicationT : implements<D, Windows::Foundation::IActivationFactory, Microsoft::Toolkit::Win32::UI::XamlHost::IXamlApplicationFactory, I...>
    {
        using instance_type = Microsoft::Toolkit::Win32::UI::XamlHost::XamlApplication;

        hstring GetRuntimeClassName() const
        {
            return L"Microsoft.Toolkit.Win32.UI.XamlHost.XamlApplication";
        }
        auto CreateInstance(Windows::Foundation::Collections::IVector<Windows::UI::Xaml::Markup::IXamlMetadataProvider> const& providers, Windows::Foundation::IInspectable const& baseInterface, Windows::Foundation::IInspectable& innerInterface)
        {
            return impl::composable_factory<T>::template CreateInstance<Microsoft::Toolkit::Win32::UI::XamlHost::XamlApplication>(baseInterface, innerInterface, providers);
        }
        auto CreateInstance2(Windows::Foundation::IInspectable const& baseInterface, Windows::Foundation::IInspectable& innerInterface)
        {
            return impl::composable_factory<T>::template CreateInstance<Microsoft::Toolkit::Win32::UI::XamlHost::XamlApplication>(baseInterface, innerInterface);
        }
        [[noreturn]] Windows::Foundation::IInspectable ActivateInstance() const
        {
            throw hresult_not_implemented();
        }
    };
}

#if defined(WINRT_FORCE_INCLUDE_XAMLAPPLICATION_XAML_G_H) || __has_include("XamlApplication.xaml.g.h")
#include "XamlApplication.xaml.g.h"
#else

namespace winrt::Microsoft::Toolkit::Win32::UI::XamlHost::implementation
{
    template <typename D, typename... I>
    using XamlApplicationT = XamlApplication_base<D, I...>;
}

#endif
